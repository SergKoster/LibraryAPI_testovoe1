# Инструкция по запуску

## 1. Клонируйте репозиторий
Сначала надо клонировать репозиторий. Так вы получите сам проект. 
```bash
git clone https://github.com/SergKoster/LibraryAPI_testovoe1.git
cd LibraryAPI_testovoe1
```
## 2. Создайте и активируйте виртуальное окружение
```bash
python -m venv venv
# Windows:
venv\Scripts\activate
# Linux/Mac:
source venv/bin/activate
```
У вас может не работать activate, если вы используете powershell,пропишите:
```bash
venv\Scripts\activate.ps1
```
## 3. Установите зависимости
```bash
pip install -r requirements.txt
```
## 4. Настройте .env
`.env` - это файл, содержащий информацию, нужную для работы базы данных, токенов jwt и подобных утилит
```bash
SECRET_KEY=your_secret_key
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_password
POSTGRES_DB=library_db
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
```
Это только пример! Прописывать данные нужно в соответствии с Вашим проектом, в данном случае показаны все нужные поля, которые нужно заполнить, для корректной работы проекта.

## 5. Миграции
```bash
alembic upgrade head
```
Данное действие нужно для того, чтобы все таблицы корректно создались в базе данных.

## 6. Запуск сервера
```bash
uvicorn main:app --reload
```

## Запуск тестов
Чтобы запустить тесты, достаточно прописать данную команду в корне проекта:
```bash
pytest
```

# Описание структуры проекта

Проект составлен по такой структуре:
```bash
.
├── app/                     # Основной код приложения
│   ├── api/                 # Роутеры FastAPI (users, books, borrows, readers, auth)
│   ├── core/                # Базовые настройки, конфиги, база данных
│   ├── crud/                # CRUD-логика для работы с БД (отдельно для каждой сущности)
│   ├── models/              # SQLAlchemy модели
│   ├── schemas/             # Pydantic-схемы (валидация и сериализация)
│   └── migrations/          # Alembic — миграции для БД
├── tests/                   # Тесты (Pytest)
├── main.py                  # Точка входа в приложение (FastAPI instance)
├── alembic.ini              # Конфиг Alembic для миграций
├── requirements.txt         # Список зависимостей
├── .env                     # Переменные окружения (не входит в git)
└── README.md                # Описание проекта и инструкция по запуску

```

# Структура БД

4 таблицы
- users |    Таблица пользователей (библиотекарей) | Поля: id, email, hashed_password
- books |    Таблица с книгами | Поля: id, title, author, year, isbn, copies, description(поле нигде не используется, нужно для демонстрации alembic миграции)
- readers |  Таблица с читателями | Поля: id, name, email
- borrows |  Таблица с записями о том, какие читатели взяли какие книги | Поля: id, book_id, reader_id, borrow_date, return_date

Такая структура показась мне самой простой для базы данных, она соответствует всем требованиям ТЗ.

# Бизнес логика

## 1. Книга выдаётся, только если кол-во её копий больше 0

Когда в API посылается запрос на выдачу книги читателю, сервер проверяет количество доступных копий (поле copies, таблица books) у нужной книги. Если копий 0, сервер возвращает ошибку, если копий больше 0 (хотя бы 1), сервер записывает в БД запись о том, что пользователь взял книгу, а так же вычитает 1 из столбца copies у соответствующей книги. Это означает, что, когда читатель берёт книгу, кол-во доступных копий этой книги в базе данных уменьшается на 1 (поле copies, таблица books).

## 2. Книга не выдаётся, если читатель уже взял её

При попытке создать запись о том, что читатель взял книгу, сервер проверяет, есть ли в таблице borrows запись с тем же reader_id и book_id, где return_date отсутствует (что говорит о том, что пользователь ещё не вернул книгу). Если такая запись есть, сервер вернёт ошибку (исключение). Если такой записи не будет, соответствующая запись будет добавлена в borrows без ошибок.

## 3. Книга не выдаётся, есть читатель уже взял более 3 книг

Сервер проверяет количество записей в таблице borrows с нужным reader_id, где return_date отсутствует. Если таких записей 3 и более, сервер вернёт исключение, если записей меньше 3 - исключения не будет.

## 4. Книгу нельзя вернуть, если читатель её не брал, или уже вернул

При попытке вернуть книгу, сервер сверяется с БД: если в таблице borrows нет записи о том, что читатель брал эту книгу (проверка по borrow_id), сервер вернёт исключение. Если в таблице borrows есть запись, но там уже выставлен return_date, сервер вернёт исключение.

# Описание реализации аутентификации

## Хэширование пароля

В проекте используется библиотека passlib, с помощью которой реализовано хэширование пароля. При регистрации нового пользователя (POST /auth/register), сервер получает пароль, хэширует его 
```python
from passlib.context import CryptContext
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
hashed = pwd_context.hash(plain_password)
```
затем, уже хэшированный пароль, добавляется в БД (таблица users, поле hashed_password).

## Генерация JWT-токена

После успешного логина (POST /auth/login) по форме OAuth2PasswordRequestForm создаётся токен доступа: 
```python
from jose import jwt
payload = {"sub": str(user.id), "exp": now + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)}
token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
```
Здесь в payload токена добавляется информация о его сроке действия, а так же о пользователе, к которому привязан токен
Библиотека python-jose выбрана за простоту и соответствие стандарту RFC 7519, а также активную поддержку.

## Проверка токена и получение текущего пользователя

Вручную не парсим заголовок: используем `OAuth2PasswordBearer(tokenUrl="/auth/login")`, который автоматически забирает заголовок `Authorization: Bearer {token}`.

Depends в ручках:
```python
def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -> User:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = int(payload.get("sub"))
    except JWTError:
        raise HTTPException(status_code=401, detail="Could not validate credentials")
    user = db.get(User, user_id)
    if not user:
        raise HTTPException(status_code=401, detail="User not found")
    return user
```
Если токен просрочен, подделан или пользователь удалён — возвращается 401 Unauthorized с заголовком `WWW-Authenticate: Bearer`.

## Какие эндпоинты защищены

Защищены все эндпоинты кроме:
- auth/register
- auth/login
- /books

По ТЗ login и register не должны быть защищены, books было решено так же оставить без защиты, чтобы список доступных книг мог увидеть любой читатель/клиент.

В `/books/* все эндпоинты защищены`.

## Разбор библиотек

- `passlib` и `python-jose` выбраны за простоту. Эти библиотеки просто интегрировать в проект и они предоставляют весь необходимый функционал. Так же python-jose хорошо совместим с FastAPI, который используется по ТЗ.
- `python-multipart` - добавлен для работы с формой OAuth2PasswordRequestForm, которая нужна для логина по двум полям (обычно `login` и `password`).

# Творческая часть

## Поиск по именам

Будет полезно иметь эндпоинты, получающие на вход имя пользователя, или название книги, и возвращать они будут все соответствующие результаты из БД.
На вход: поле БД, по которому ведётся поиск, а так же значение этого поля. На выходе все записи, которые содержат введённое значение (Например - поиск по названию книги. Вход "Властелин". Выход - Book-элементы с названиями "Властелин колец", "Властелин овец" и т.д.)

## Логирование

Можно добавить в проект логирование всех действий, обращений к ручкам и т.д. Так будет проще отслеживать данные об ошибках или, например, популярных книгах. Логирование можно добавить как простую запись в лог-файл данных о входах/выходах ручек.